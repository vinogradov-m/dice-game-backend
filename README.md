# Local Environment Setup

## Prerequisites

- Please install the most recent versions of docker and docker-compose for your
  operating system.
- Make sure that you have Node.js v18 installed on your machine. Alternatively, you can
  launch the application in the docker container. Please see the instructions below.

## Configuration

The repository contains an example of the .env file. Please use it to create a
configuration file:

```shell
cp .env.example .env
```

For the simplicity sake, you can use the values from the example file if they don't
conflict with your local environment.

## Running the application in the docker container

Please find the example of the docker-compose.override.yml file in the root of the
repository and use it to override the default configuration. It contains a definition of
the service that runs the application in the docker container.

```shell
cp docker-compose.override.example.yaml docker-compose.override.yaml
```

Make sure that the port mapping does not conflict with the ports used by other
applications on your machine.

## Other adjustments

Additionally, you may want to use a docker-compose.override.yml file to override the
default configuration than cannot be changed via environment variables, for example, the
main command to run in the container. Please refer to the
docker-compose.override.example.yml file for the example.

# Adding initial data

You can find the initial data in the "fixtures" folder. Execute the 001-initial-data.sql
script in your favorite database editor, e.g. pgadmin or DataGrip. If you have postgres
client installed, you can run the following command:

```shell
psql -h localhost -p 5432 -U postgres -d dice_game -f fixtures/001-initial-data.sql
```

Adjust the port and the database name to make them match the values from your .env file.

# Interacting with the application

The easiest way to interact with the application is to use the Postman. Please refer to
[this article](https://blog.postman.com/postman-now-supports-socket-io/) for more
details.

## Authentication

The application expects that the login of the user is passed in the "token" query param.
I.e. the URL should look like this: `ws://locahost:3000/game?token=alice`

## Events

The following events are available for communication between clients and the server:

```typescript
// generated by the client
RoomListRequested = 'room_list_requested',
RoomJoinRequested = 'room_join_requested',
GameStartRequested = 'game_start_requested',
DieRollRequested = 'die_roll_requested',

// happens on the server
RoomListGenerated = 'room_list_generated',
JoinedRoom = 'joined_room',
RoomJoinFailed = 'room_join_failed',
GameStarted = 'game_started',
GameFinished = 'game_finished',
DieRolled = 'die_rolled',
DieRollFailed = 'die_roll_failed'
```

### Requesting the Room List

To request the room list, the client should emit the `room_list_requested` event. The
server will respond with the `room_list_generated` event containing the list of
available rooms.

### Joining a Room

To join a room, the client should emit the `room_join_requested` event with the room ID.
If the user successfully joins the room, the server will emit the `joined_room` event.
In case of failure, the server will emit the `room_join_failed` event. If the user tried
to re-join the room, the server will not emit any event.

### Starting a Game

To request starting a game, the client should emit the `game_start_requested` event. If
the game starts successfully, the server will emit the `game_started` event. All errors
are silently ignored, so no error message will be sent to the client in the case of
failure.

### Rolling a Die

To request rolling a die, the client should emit the `die_roll_requested` event. If the
die is rolled successfully, the server will emit the `die_rolled` event. In case of
failure, the server will emit the `die_roll_failed` event.

### Finishing a Game

The game can be finished in two ways:

1. All the users rolled the die.
1. All users who did not roll the die left the room.

When the game is finished, the server will emit the `game_finished` event.

# Room for improvements

There are a few areas where the current implementation can be improved:

## Implement Redis-based locks to prevent race conditions

To ensure data consistency and prevent race conditions, consider implementing
Redis-based locks for critical sections in the application, such as starting a new game
in a room. This is particularly important when dealing with multiple instances of the
application, as it prevents potential conflicts and data corruption.

## Expand the test coverage

The project currently contains only a single e2e test case. To improve the reliability
and maintainability of the application, it's essential to expand the test coverage. This
includes:

- Writing unit tests for individual components and services, focusing on testing their
  functionality in isolation.
- Creating more e2e test cases to cover various scenarios and edge cases, ensuring that
  the system behaves as expected when all components are integrated.

## Use a separate database for testing

To prevent tests from affecting the valid data, it is good practice to use a separate
database for testing. This can be achieved by setting up a different connection string
or configuration for the test environment.

## Improve authentication handling in tests

Currently, there are issues with handling authentication in tests (in particular,
waiting for finalizing the handshake on the server side before sending event).
